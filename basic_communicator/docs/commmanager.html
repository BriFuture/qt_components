<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- commmanager.cpp -->
  <title>CommManager Class | Qt  5.7</title>
</head>
<body>
<link href="style/online.css"                 rel="stylesheet" type="text/css">                 <div class="content"> <div class="context"> <a href="index.html">Home</a> <li>CommManager</li>
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#public-slots">Public Slots</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">CommManager Class</h1>
<!-- $$$CommManager-brief -->
<p>通讯管理器，传递查询语句和结果管理串口子线程的作用，封装了多线程，向外部提供统一的 接口，起到类似中介的作用，将 <a href="abstractprotocol.html">AbstractProtocol</a> 和实际执行串口/网络访问的类（子线程中）聚合起来，方便迭代更新 <a href="#details">More...</a></p>
<!-- @@@CommManager -->
<ul>
<li><a href="commmanager-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#CommManager">CommManager</a></b>(QObject *<i>parent</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#dtor.CommManager">~CommManager</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#addProtocol">addProtocol</a></b>(AbstractProtocol *<i>p</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const CommInfo &amp;</td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#currentCommInfo">currentCommInfo</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#delProtocol">delProtocol</a></b>(AbstractProtocol *<i>p</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#getProtocol">getProtocol</a></b>(const QString &amp;<i>objectName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> AbstractProtocol *</td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#protocol">protocol</a></b>(const QString &amp;<i>objectName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QList&lt;AbstractProtocol *&gt; &amp;</td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#protocolList">protocolList</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#resetMode">resetMode</a></b>(const QString &amp;<i>type</i>, const bool <i>halfDuplex</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#resetMode-1">resetMode</a></b>(const QString &amp;<i>className</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const CommState &amp;</td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#state">state</a></b>()</td></tr>
</table></div>
<a name="public-slots"></a>
<h2 id="public-slots">Public Slots</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#close">close</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#onQuery">onQuery</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#onRecvLineData">onRecvLineData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#onStateChanged">onStateChanged</a></b>(const CommState &amp;<i>state</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#onWriteFinish">onWriteFinish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#openDevice">openDevice</a></b>(const QString &amp;<i>name</i> = &quot;&quot;)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#stopAllQuery">stopAllQuery</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#stopCurrentQuery">stopCurrentQuery</a></b>()</td></tr>
</table></div>
<a name="signals"></a>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#cmdCountChanged">cmdCountChanged</a></b>(const int <i>remain</i>, const int <i>all</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#codeMayMessed">codeMayMessed</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#commInfoChanged">commInfoChanged</a></b>(const CommInfo &amp;<i>ci</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#recvLineData">recvLineData</a></b>(const QByteArray &amp;<i>data</i>, const int <i>count</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#recvRawData">recvRawData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#sendData">sendData</a></b>(const QByteArray &amp;<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#setCommProperty">setCommProperty</a></b>(const QString &amp;<i>key</i>, const QVariant &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#stateChanged">stateChanged</a></b>(const CommState &amp;<i>state</i>)</td></tr>
</table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="commmanager.html#init">init</a></b>(const QString &amp;<i>name</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$CommManager-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p><b class="redFont"><code>\author</code></b>BriFuture</p>
<p>通讯管理器，传递查询语句和结果管理串口子线程的作用，封装了多线程，向外部提供统一的 接口，起到类似中介的作用，将 <a href="abstractprotocol.html">AbstractProtocol</a> 和实际执行串口/网络访问的类（子线程中）聚合起来，方便迭代更新</p>
<p><b class="redFont"><code>\date</code></b>2018.07.19 This is a new Communicator Class which doesn't exactly query and process data, because the real serialPort/socket is moved into a subThread which wont block UI-thread, it is a manager class that handle the sub thread, notify serial to query, receive data from serial port / network, and transfer it into BaseComm's implementation.</p>
<p><b>Warning:</b> <b class="redFont"><code>\date</code></b> 2018.04.25</p>
<p>此前串口通讯无法正确识别下位机的发送时间间隔（数据每隔 16 ms 才被接收到）。最终在 FT232R 的驱动设置中找到了延时的根本原因 （参考<a href="http://projectgus.com/2011/10/notes-on-ftdi-latency-with-arduino/">http://projectgus.com/2011/10/notes-on-ftdi-latency-with-arduino/</a>）， 因此解决了串口通讯无法识别下位机发送时间间隙的问题。</p>
<p>Because of the delay of data coming into serial port (it is after almost 16ms that the data can be received from serial port), Finally, we found the root cause of the delay is made by the driver settings of FT232R with the help of this article: <a href="http://projectgus.com/2011/10/notes-on-ftdi-latency-with-arduino/">http://projectgus.com/2011/10/notes-on-ftdi-latency-with-arduino/</a> At last, we solved the problem of the data delay and successfully found the gap between tow sentences from slave computer.</p>
<p>example:</p>
<pre class="cpp">CommManager <span class="operator">*</span>cm <span class="operator">=</span> Comm<span class="operator">::</span>manager;
cm<span class="operator">.</span>resetMode(<span class="string">&quot;Network&quot;</span><span class="operator">,</span> <span class="keyword">true</span>);  <span class="comment">// 设为网络通讯半双工模式</span>
connect(cm<span class="operator">,</span> <span class="operator">&amp;</span>CommManager<span class="operator">::</span>recvLineData<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>SomeClass<span class="operator">::</span>recvLine);  <span class="comment">// 接收数据</span></pre>
</div>
<!-- @@@CommManager -->
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$CommManager[overload1]$$$CommManagerQObject* -->
<h3 class="fn" id="CommManager"><a name="CommManager"></a>CommManager::<span class="name">CommManager</span>(<span class="type">QObject</span> *<i>parent</i> = 0)</h3>
<p>Default constructs an instance of CommManager.</p><!-- @@@CommManager -->
<!-- $$$~CommManager[overload1]$$$~CommManager -->
<h3 class="fn" id="dtor.CommManager"><a name="dtor.CommManager"></a>CommManager::<span class="name">~CommManager</span>()</h3>
<p>关闭串口/网路，结束子线程</p>
<!-- @@@~CommManager -->
<!-- $$$addProtocol[overload1]$$$addProtocolAbstractProtocol* -->
<h3 class="fn" id="addProtocol"><a name="addProtocol"></a><span class="type">void</span> CommManager::<span class="name">addProtocol</span>(<span class="type"><a href="abstractprotocol.html">AbstractProtocol</a></span> *<i>p</i>)</h3>
<p>向 <a href="commmanager.html">CommManager</a> 管理器中添加协议，以便处理相应协议的数据</p>
<p>example:</p>
<pre class="cpp">CommManager <span class="operator">*</span>manager <span class="operator">=</span> Comm<span class="operator">::</span>manager;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;List Size: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> manager<span class="operator">.</span>protocolList()<span class="operator">.</span>size();  <span class="comment">// assume the size now is N = 10, then output is &quot;List Size: 10&quot;</span>
AbstractProtocol <span class="operator">*</span>p  <span class="operator">=</span> <span class="keyword">new</span> ImplProtocol;  <span class="comment">// ImplProtocol must be implement subclass of AbstractProtocol</span>
manager<span class="operator">-</span><span class="operator">&gt;</span>addProtocol(p);  <span class="comment">// now ImplProtocol is added, the data will be transmitted to this protocol if it is enabled.</span>
qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;List Size: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> manager<span class="operator">.</span>protocolList()<span class="operator">.</span>size();  <span class="comment">// output is &quot;List Size: 11&quot;</span></pre>
<p><b>See also </b><a href="commmanager.html#onRecvLineData">CommManager::onRecvLineData</a> and <a href="commmanager.html#delProtocol">CommManager::delProtocol</a>.</p>
<!-- @@@addProtocol -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close"><a name="close"></a><code>[virtual slot] </code><span class="type">void</span> CommManager::<span class="name">close</span>()</h3>
<p>关闭串口并清空指令队列</p>
<p>example:</p>
<pre class="cpp">CommManager <span class="operator">*</span>m <span class="operator">=</span> Comm<span class="operator">::</span>manager;
m<span class="operator">-</span><span class="operator">&gt;</span>openDevice(<span class="string">&quot;COM1&quot;</span>);  <span class="comment">// 打开 COM1 串口</span>
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
m<span class="operator">-</span><span class="operator">&gt;</span>close();  <span class="comment">// 关闭打开的 COM1 串口</span></pre>
<!-- @@@close -->
<!-- $$$cmdCountChanged[overload1]$$$cmdCountChangedconstintconstint -->
<h3 class="fn" id="cmdCountChanged"><a name="cmdCountChanged"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">cmdCountChanged</span>(const <span class="type">int</span> <i>remain</i>, const <span class="type">int</span> <i>all</i>)</h3>
<p>通知其他组件指令数目有变化</p>
<!-- @@@cmdCountChanged -->
<!-- $$$codeMayMessed[overload1]$$$codeMayMessed -->
<h3 class="fn" id="codeMayMessed"><a name="codeMayMessed"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">codeMayMessed</span>()</h3>
<!-- @@@codeMayMessed -->
<!-- $$$commInfoChanged[overload1]$$$commInfoChangedconstCommInfo& -->
<h3 class="fn" id="commInfoChanged"><a name="commInfoChanged"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">commInfoChanged</span>(const <span class="type">CommInfo</span> &amp;<i>ci</i>)</h3>
<!-- @@@commInfoChanged -->
<!-- $$$currentCommInfo[overload1]$$$currentCommInfo -->
<h3 class="fn" id="currentCommInfo"><a name="currentCommInfo"></a>const <span class="type">CommInfo</span> &amp;CommManager::<span class="name">currentCommInfo</span>()</h3>
<p>返回当前通讯器的 CommInfo <b class="redFont"><code>\return</code></b></p>
<!-- @@@currentCommInfo -->
<!-- $$$delProtocol[overload1]$$$delProtocolAbstractProtocol* -->
<h3 class="fn" id="delProtocol"><a name="delProtocol"></a><span class="type">void</span> CommManager::<span class="name">delProtocol</span>(<span class="type"><a href="abstractprotocol.html">AbstractProtocol</a></span> *<i>p</i>)</h3>
<p>删除管理器中的协议</p>
<p>example:</p>
<pre class="cpp">CommManager <span class="operator">*</span>manager <span class="operator">=</span> Comm<span class="operator">::</span>manager;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;List Size: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> manager<span class="operator">.</span>protocolList()<span class="operator">.</span>size();  <span class="comment">// assume the size now is N = 10, then output is &quot;List Size: 10&quot;</span>
manager<span class="operator">-</span><span class="operator">&gt;</span>delProtocol(p);  <span class="comment">// p points to an instance of ImplProtocol</span>
qDebug() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;List Size: &quot;</span> <span class="operator">&lt;</span><span class="operator">&lt;</span> manager<span class="operator">.</span>protocolList()<span class="operator">.</span>size();  <span class="comment">// output is &quot;List Size: 9&quot;</span></pre>
<p><b>See also </b><a href="commmanager.html#addProtocol">CommManager::addProtocol</a>.</p>
<!-- @@@delProtocol -->
<!-- $$$getProtocol[overload1]$$$getProtocolconstQString& -->
<h3 class="fn" id="getProtocol"><a name="getProtocol"></a><span class="type">T</span> CommManager::<span class="name">getProtocol</span>(const <span class="type">QString</span> &amp;<i>objectName</i>)</h3>
<!-- @@@getProtocol -->
<!-- $$$init[overload1]$$$initconstQString& -->
<h3 class="fn" id="init"><a name="init"></a><code>[protected] </code><span class="type">void</span> CommManager::<span class="name">init</span>(const <span class="type">QString</span> &amp;<i>name</i>)</h3>
<p>将 mode 字符串传递给负责构造 <a href="abstractcomm.html">AbstractComm</a> 的工厂类。 Pass the mode string into factory that responds for construct BaseComm @param mode</p>
<!-- @@@init -->
<!-- $$$onQuery[overload1]$$$onQuery -->
<h3 class="fn" id="onQuery"><a name="onQuery"></a><code>[virtual slot] </code><span class="type">void</span> CommManager::<span class="name">onQuery</span>()</h3>
<p>发送的指令可能不会立即被下位机执行，需要等待一定时间接收下位机的反馈。</p>
<p>example</p>
<pre class="cpp"><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
manager<span class="operator">-</span><span class="operator">&gt;</span>onQuery();  <span class="comment">// 从协议列表中找出一个用命令的协议，将该命令写入到串口等设备中进行查询</span></pre>
<!-- @@@onQuery -->
<!-- $$$onRecvLineData[overload1]$$$onRecvLineDataconstQByteArray& -->
<h3 class="fn" id="onRecvLineData"><a name="onRecvLineData"></a><code>[slot] </code><span class="type">void</span> CommManager::<span class="name">onRecvLineData</span>(const <span class="type">QByteArray</span> &amp;<i>data</i>)</h3>
<p>接收到来自串口的数据后，将其转发给各个协议</p>
<!-- @@@onRecvLineData -->
<!-- $$$onStateChanged[overload1]$$$onStateChangedconstCommState& -->
<h3 class="fn" id="onStateChanged"><a name="onStateChanged"></a><code>[slot] </code><span class="type">void</span> CommManager::<span class="name">onStateChanged</span>(const <span class="type">CommState</span> &amp;<i>state</i>)</h3>
<p>在设备的状态改变时，将状态转发给其它层</p>
<!-- @@@onStateChanged -->
<!-- $$$onWriteFinish[overload1]$$$onWriteFinish -->
<h3 class="fn" id="onWriteFinish"><a name="onWriteFinish"></a><code>[slot] </code><span class="type">void</span> CommManager::<span class="name">onWriteFinish</span>()</h3>
<p>在实际串口执行完查询后进行相应操作</p>
<p>@date 2018.06.16 可能存在的bug： 假设查询队列为 Q1, Q2, Q3 回复为 A1, A2 A3, A4 这里的 A2 A3 是在查询完 Q2 之后同时回复 然而此时协议的定时器尚未工作，在接收到 A3 回复时由于定时器发生错误导致查询队列（程序）崩溃， 因此协议在接收指令时务必判断定时器是否工作</p>
<!-- @@@onWriteFinish -->
<!-- $$$openDevice[overload1]$$$openDeviceconstQString& -->
<h3 class="fn" id="openDevice"><a name="openDevice"></a><code>[virtual slot] </code><span class="type">void</span> CommManager::<span class="name">openDevice</span>(const <span class="type">QString</span> &amp;<i>name</i> = &quot;&quot;)</h3>
<p>打开指定设备，若参数 name 为空，则默认打开最后一次使用的设备</p>
<p>example: 打开串口 COM1</p>
<pre class="cpp">CommManager <span class="operator">*</span>manager <span class="operator">=</span> Comm<span class="operator">::</span>manager;
manager<span class="operator">-</span><span class="operator">&gt;</span>openDevice(<span class="string">&quot;COM1&quot;</span>);  <span class="comment">// if serial port COM1 is free to use, then COM1 will be occupied by the program</span></pre>
<p>连接服务器 192.168.0&#x2e;100 / localhost，连接网络前需要设置端口</p>
<pre class="cpp">  manager<span class="operator">-</span><span class="operator">&gt;</span>setCommProperty(<span class="string">&quot;port&quot;</span><span class="operator">,</span> <span class="number">8080</span>);
  manager<span class="operator">-</span><span class="operator">&gt;</span>openDevice(<span class="string">&quot;localhost&quot;</span>);  <span class="comment">// connect to localhost</span>
<span class="comment">// manager-&gt;openDevice(&quot;192.168.0.100&quot;);  // effects the same as before</span></pre>
<p><b>See also </b><a href="commmanager.html#setCommProperty">CommManager::setCommProperty</a> and <a href="commmanager.html#close">CommManager::close</a>.</p>
<!-- @@@openDevice -->
<!-- $$$protocol[overload1]$$$protocolconstQString& -->
<h3 class="fn" id="protocol"><a name="protocol"></a><span class="type"><a href="abstractprotocol.html">AbstractProtocol</a></span> *CommManager::<span class="name">protocol</span>(const <span class="type">QString</span> &amp;<i>objectName</i>)</h3>
<!-- @@@protocol -->
<!-- $$$protocolList[overload1]$$$protocolList -->
<h3 class="fn" id="protocolList"><a name="protocolList"></a>const <span class="type">QList</span>&lt;<span class="type"><a href="abstractprotocol.html">AbstractProtocol</a></span> *&gt; &amp;CommManager::<span class="name">protocolList</span>()</h3>
<!-- @@@protocolList -->
<!-- $$$recvLineData[overload1]$$$recvLineDataconstQByteArray&constint -->
<h3 class="fn" id="recvLineData"><a name="recvLineData"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">recvLineData</span>(const <span class="type">QByteArray</span> &amp;<i>data</i>, const <span class="type">int</span> <i>count</i> = 0)</h3>
<!-- @@@recvLineData -->
<!-- $$$recvRawData[overload1]$$$recvRawDataconstQByteArray& -->
<h3 class="fn" id="recvRawData"><a name="recvRawData"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">recvRawData</span>(const <span class="type">QByteArray</span> &amp;<i>data</i>)</h3>
<p>通知其他组件从串口/网络中接收到的原始数据（即不一定包含 AbstractProtocol::LineSeperator 的数据）</p>
<!-- @@@recvRawData -->
<!-- $$$resetMode[overload1]$$$resetModeconstQString&constbool -->
<h3 class="fn" id="resetMode"><a name="resetMode"></a><span class="type">void</span> CommManager::<span class="name">resetMode</span>(const <span class="type">QString</span> &amp;<i>type</i>, const <span class="type">bool</span> <i>halfDuplex</i>)</h3>
<p>CommManager::resetMode</p>
<p>This is an overloaded function.</p>
<p>example:</p>
<pre class="cpp"><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
manager<span class="operator">-</span><span class="operator">&gt;</span>resetMode(<span class="string">&quot;Network&quot;</span><span class="operator">,</span> <span class="keyword">false</span>);  <span class="comment">//设为网络通讯全双工模式s</span></pre>
<!-- @@@resetMode -->
<!-- $$$resetMode$$$resetModeconstQString& -->
<h3 class="fn" id="resetMode-1"><a name="resetMode-1"></a><span class="type">void</span> CommManager::<span class="name">resetMode</span>(const <span class="type">QString</span> &amp;<i>className</i>)</h3>
<p>指定的className，重设Comm模式 提供该接口是为了在某些特殊情况下，现有的通讯器无法满足要求，需要扩展通讯器时，通过该方法生成自定义的通讯器类</p>
<p>This is an overloaded function.</p>
<p>扩展通讯器示例：</p>
<pre class="cpp">Comm<span class="operator">::</span>factory<span class="operator">-</span><span class="operator">&gt;</span>addComm(SubComm<span class="operator">::</span>staticMetaObject<span class="operator">,</span> SubComm<span class="operator">::</span>commInfo);  <span class="comment">// SubComm is a subclass of Abstract Comm</span>
Comm<span class="operator">::</span>manager<span class="operator">-</span><span class="operator">&gt;</span>resetMode(<span class="string">&quot;SubComm&quot;</span>);  <span class="comment">// 构建一个新的通讯器</span></pre>
<p>common example:</p>
<pre class="cpp"><span class="comment">// assume that there is a communicator VirtualCom OTHER THAN ComFullDuplex</span>
CommManager <span class="operator">*</span>manager <span class="operator">=</span> Comm<span class="operator">::</span>manager;
<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
manager<span class="operator">-</span><span class="operator">&gt;</span>resetMode(<span class="string">&quot;VirtualCom&quot;</span>);  <span class="comment">// Data will be received from VirtualCom</span></pre>
<p><b>See also </b><a href="commfactory.html">CommFactory</a> and <a href="commmanager.html#resetMode">CommManager::resetMode</a>(const QString &amp;type, const bool halfDuplex).</p>
<!-- @@@resetMode -->
<!-- $$$sendData[overload1]$$$sendDataconstQByteArray& -->
<h3 class="fn" id="sendData"><a name="sendData"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">sendData</span>(const <span class="type">QByteArray</span> &amp;<i>data</i>)</h3>
<p>表示数据已经由通讯器发送到串口/网络中</p>
<!-- @@@sendData -->
<!-- $$$setCommProperty[overload1]$$$setCommPropertyconstQString&constQVariant& -->
<h3 class="fn" id="setCommProperty"><a name="setCommProperty"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">setCommProperty</span>(const <span class="type">QString</span> &amp;<i>key</i>, const <span class="type">QVariant</span> &amp;<i>value</i>)</h3>
<p>设置串口/网络设备的属性</p>
<p><b>See also </b><a href="abstractcomm.html#setCommProperty">AbstractComm::setCommProperty</a>.</p>
<!-- @@@setCommProperty -->
<!-- $$$state[overload1]$$$state -->
<h3 class="fn" id="state"><a name="state"></a>const <span class="type">CommState</span> &amp;CommManager::<span class="name">state</span>()</h3>
<p>返回串口状态</p>
<!-- @@@state -->
<!-- $$$stateChanged[overload1]$$$stateChangedconstCommState& -->
<h3 class="fn" id="stateChanged"><a name="stateChanged"></a><code>[signal] </code><span class="type">void</span> CommManager::<span class="name">stateChanged</span>(const <span class="type">CommState</span> &amp;<i>state</i>)</h3>
<p>通知串口/网络设备的状态有变化</p>
<!-- @@@stateChanged -->
<!-- $$$stopAllQuery[overload1]$$$stopAllQuery -->
<h3 class="fn" id="stopAllQuery"><a name="stopAllQuery"></a><code>[virtual slot] </code><span class="type">void</span> CommManager::<span class="name">stopAllQuery</span>()</h3>
<p>停止所有查询，并通知协议管理器也重置查询</p>
<!-- @@@stopAllQuery -->
<!-- $$$stopCurrentQuery[overload1]$$$stopCurrentQuery -->
<h3 class="fn" id="stopCurrentQuery"><a name="stopCurrentQuery"></a><code>[virtual slot] </code><span class="type">void</span> CommManager::<span class="name">stopCurrentQuery</span>()</h3>
<p>停止当前查询，若协议中有指令未执行，接着执行下一条指令</p>
<!-- @@@stopCurrentQuery -->
</div>
</div> </div></body>
</html>
